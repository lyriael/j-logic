%!TEX root = ../../bachelors_thesis.tex
\section{Conquer}
The conquer-step consists mainly in the analyzing of the formula and only as a very last step the typical recursion is used when the result of all atoms of a formula evaluates to the overall result of the original formula. This is actually very simple compared to the analyzing part that comes before. 

First we have to know what to look up in the cs-list for which proof constant. Those proof constants and the corresponding terms will be called \emph{musts} since even now I lack a more suitable word for it and in the source code it is always referred as such.

Once that the \emph{musts} have been obtained we can search the cs-list of terms that match. Since a \emph{must} usually consists of variables that are not determined we will usually get more then one possible match per proof term. Also since cs-list allows terms that contain variables as well this will impose further conditions on the possible choice of the term of a proof term. In the second step all those possibilities and conditions are collected.

Then in the third and most important step those configurations and conditions will be merged. It will be checked if there is a possible combination from the given options such as the atomized formula is provable. It is then only a small step to collect the results of all other atoms of the original formula to determine the provability of the original formula.


\subsection{Get Must}
The operator rules which were presented in Chapter XX \todoFormat{Find (and write!!) Chapter} gives us the instruction how we can take a formula apart to look the individual proof term up in the cs-list. The rule for the Sum-Operation was already used in the divide-step for the sumsplit in \ref{sumsplit}.

It can be summarized that each Multiplication-Operation in a term adds one variable, which will here be called \emph{wilds} or \emph{x-wilds} where as a Bang-Operation will replace an existing \emph{wild} with a new wild combined with the proof constant of that case. 

The algorithm starts at the top of the syntax tree of the proof term of the formula and for each level it descends it recursively calls the same method on this child nodes.

So for a term like this $(a*(!b))*c):F$ the following will be evaluated:

\begin{equation}\label{musts}
\begin{split}
	(a*(!b))*b):F \\
	& \Rightarrow a*(!b):  X_1 \rightarrow F \\
	& \Rightarrow b:  X_1
\end{split}
\end{equation}
\begin{equation}\label{musts1}
\begin{split}
	(a*(!b)): X_1 \rightarrow F \\
	& \Rightarrow a: X_2 \rightarrow (X_1 \rightarrow F)\\
	& \Rightarrow !b: X_2
\end{split}
\end{equation}
\begin{equation}\label{musts2}
\begin{split}
	!b: X_2 \\
	& \Rightarrow X_2 = b:X_3
\end{split}
\end{equation}

$X_2$ will be replaced by $b:X_3$ so our final \emph{must}-list will look like this: 
\begin{equation}\label{must-list}
musts_{(a*(!b))*c):F} = \{a: [(b:X_3) \rightarrow (X_1 \rightarrow F)], b: [X_1, X_3] \}
\end{equation}

As can be seen in this example a proof constant my have more than one term that needs to be looked up in the cs-list.

\subsection{Configurations and Conditions}
Now the \emph{must}-list from the previous step will be compared with the given cs-list. The terms of a proof constant in \emph{must} will be matched against those the same proof constant in the cs-list. This will give us what I call a \emph{configuration table}. The conditions which are only important in special situations will be postponed for a later example.

For convenience it will be asserted that the cs-list is given in the same structure as the must-list. The function used in the code to do this operates on a proof constant level, that means it iterates through the must-list and for each of the proof constants terms it compares it to the terms of the same proof constant of the cs-list. Therefore we will look only at one proof constant in this example as well.

\vspace{0.2cm}

Term from must-list: $a:(X_2\rightarrow (X_1 \rightarrow F))$

Cs-list\footnote{contains only entries for the proof constant $a$} : $\{a: [A \rightarrow (A \rightarrow F), (b:B) \rightarrow A, B, C \rightarrow (A \rightarrow F), (b:B) \rightarrow (B \rightarrow F)]\}$

\vspace{0.2cm}
\begin{table}[ht]
\centering
\begin{tabular}{ c || c c }
	Term: $(X_2\rightarrow (X_1 \rightarrow F))$	& $X_1$ & $X_2$ \\
	\hline
	$A \rightarrow (A \rightarrow F)$ 		& $A$ & $A$ \\
	$(b:B) \rightarrow A$ 					& - & - \\
	$B$ 										& - & - \\
	$C \rightarrow (A \rightarrow F)$ 		& $A$ & $C$\\
	$(b:B) \rightarrow (B \rightarrow F)$ 	& $B$ & $b:B$\\
\end{tabular}
\caption{Matching the term of $a$ from the must-list with those of the cs-list.}
\end{table}


\subsubsection{Y-Wilds}\todoFormat{Would be nice to have a X-Wild title somewhere as well}
Later the the definition of the cs-list was changed such that it may also include more general formulas using variables. The purpose behind it was to have a way to include concepts such as tautologies. As a convention those special variables in the cs-list will be called \emph{y-wilds} and be denoted as $Y_i$. An example of such a special entry in the cs-list would be $t:Y_1 \rightarrow (Y_2 \rightarrow Y_1)$ where $Y_1$ and $Y_2$ may represent any term\footnote{For this implementation only terms that use only the operations for justification logic as introduced in Chapter XX may be used.}

As mentioned before\todoFormat{where?} this additional feature made the process of comparing the \emph{musts} with the corresponding entries in cs-list more complicated. The problems lies in the fact when comparing $X_i$ with $Y_j$ either could be anything. To handle this situation I had to add a way to add a condition to a certain configuration. Even then combinations of \emph{wilds} would pose problems that could not consequently be represented and handled through the conditions. Eventually I reached the conclusion that those trouble-making situations could actually not occur based on the following assumption:

\begin{assertion}
Each $X_i$ occurs at most once within one \emph{must}-term.\footnote{This basically follows from the way how the \emph{X-wilds} are generated. Each Multiplication-Operator gives exactly one new \emph{X-wild}.}
\end{assertion}

The algorithm used to compare the two terms might give the impression that through replacement it is possible to have more than one $X_i$ for a certain $i$, but the algorithm works in a way that prevents that. For more detail see the Implementation Chapter.\todoFormat{link to chapter}

\begin{definition}
A \emph{condition} is passed as tuple with two positions. The first position gives the $X_i$ to which the condition applies and the second position holds the condition posed on this \emph{X-wild}. The condition may contain any term, including \emph{X-wilds} or \emph{Y-wilds}.
\end{definition}

\begin{assertion}
A condition never contain \emph{X-wilds} and \emph{Y-wilds} at the same time.
\end{assertion}

This assertion is crucial for the evaluation of the 

\subsection{Merge}



