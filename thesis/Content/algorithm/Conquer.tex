%!TEX root = ../../bachelors_thesis.tex
\section{Conquer}
First we have to know what to look up in the cs-list for which proof constant. Those proof constants and the corresponding terms will be called \emph{musts} since even now I lack a more suitable word for it and in the source code it is always referred as such.

Once that the \emph{musts} have been obtained we can search the cs-list for terms that match it. Since a \emph{must} usually consists of variables (\emph{X-wilds})that are not determined it is possible that we get more then one match per proof term. Also since the cs-list allows terms that contain variables (\emph{Y-wilds})as well this will impose further conditions on the possible choice of the term of a proof term. In the second step all those possibilities and conditions are collected.

Then in the third and most important step those configurations and conditions will be merged. It will be checked if there is a possible combination from the given options such as the atomized formula is provable. It is then only a small step to collect the results of all other atoms of the original formula to determine the provability of the original formula. 

\subsection{Get Must}
The operator rules which were presented in Chapter XX gives us the instruction how we can take a formula apart to look the individual proof term up in the cs-list. The rule for the Sum-Operation was already used in the divide-step for the sumsplit in \ref{sumsplit}.

It can be summarized that each Multiplication-Operation in a term adds one variable, which will here be called \emph{wilds} or \emph{x-wilds} where as a Bang-Operation will replace an existing \emph{wild} with a new wild combined with the proof constant of that case. 

The algorithm starts at the top of the syntax tree of the proof term of the formula and for each level it descends it recursively calls the same method on this child nodes.

So for a term like this $(a*(!b))*c):F$ the following will be evaluated:

\begin{equation}\label{musts}
\begin{split}
	(a*(!b))*b):F \\
	& \Rightarrow a*(!b):  X_1 \rightarrow F \\
	& \Rightarrow b:  X_1
\end{split}
\end{equation}
\begin{equation}\label{musts1}
\begin{split}
	(a*(!b)): X_1 \rightarrow F \\
	& \Rightarrow a: X_2 \rightarrow (X_1 \rightarrow F)\\
	& \Rightarrow !b: X_2
\end{split}
\end{equation}
\begin{equation}\label{musts2}
\begin{split}
	!b: X_2 \\
	& \Rightarrow X_2 = b:X_3
\end{split}
\end{equation}

$X_2$ will be replaced by $b:X_3$ so our final \emph{must}-list will look like this: 
\begin{equation}\label{must-list}
musts_{(a*(!b))*c):F} = \{a: [(b:X_3) \rightarrow (X_1 \rightarrow F)], b: [X_1, X_3] \}
\end{equation}

As can be seen in this example a proof constant my have more than one term that needs to be looked up in the cs-list.

\subsection{Matching and Conditions}
Until very recently this step had a very different approach, which unfortunately proved to hold more than one mistake. Some could be fixed but one remained that could not be fixed with the original approach so after I though I would be done with coding I had to reimplement this whole part again. But in exchange it is no operating as it is supposed to.




\par This concludes not only the merge step but the whole divide and conquer chapter. I personally have found it rather easy to understand the individual steps but difficult to not get lost in the overall view. For that reason chapter \ref{chap: Example} will cover one single example designed to show all aspects of the algorithm and run it through to understand it better.